#pragma config(Sensor, in1,    lineBoi,        sensorLineFollower)
#pragma config(Sensor, dgtl1,  sonarFront,     sensorSONAR_inch)
#pragma config(Sensor, dgtl3,  sonarBack,      sensorSONAR_inch)
#pragma config(Motor,  port2,           rightMotor,    tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port3,           leftMotor,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           armMotor,      tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port5,           clawMotor,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port6,           wristMotor,    tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//Moki|Baby

// SCROLL DOWN TO THE MAIN FUNCTION TO SEE THE ACTUAL PROGRAM

/*
* #TODO:
* - fix the amount of time that the moveArm function runs for
* - fix the speed/time for clawState
* - finish the goddamn program (programn)
*/

/*
  There is a bunch of function overloading here. That's when you make multiple functions with the same name.
  Don't panic! Just call the version of the function that you want and you're good.
  e.g. If you want to move forward at speed 5 for 5 seconds, call forward(5,5).
  And If you want to just start moving forward at speed 5, call forward(5).
*/
void stop(int time) { // stop for some time
	motor[leftMotor] = 0;
	motor[rightMotor] = 0;
	wait1Msec(time);
}

void stop() { // just stop
	motor[leftMotor] = 0;
	motor[rightMotor] = 0;
}

void forward(int speed, int time) { // move forward at some speed for some time
	motor[leftMotor] = speed;
	motor[rightMotor] = speed;
	wait1Msec(time);
}

void forward(int speed) { // just move forward
	motor[leftMotor] = -speed;
	motor[rightMotor] = -speed;
}

void backward(int speed, int time) { // move backward at some speed for some time
	motor[leftMotor] = -speed;
	motor[rightMotor] = -speed;
	wait1Msec(time);
}

void backward(int speed) { // just move backward
	motor[leftMotor] = -speed;
	motor[rightMotor] = -speed;
}

void turnLeft(int angle) {
  int turnSpeed = 16;
  motor[leftMotor] = -turnSpeed;
	motor[rightMotor] = turnSpeed;
	wait1Msec(angle * 50);
}

void turnRight(int angle) {
  int turnSpeed = 16;
  motor[leftMotor] = turnSpeed;
  motor[rightMotor] = -turnSpeed;
  wait1Msec(angle * 50);
}

void moveArm(int angle) { // angle is in degrees, clockwise if you look at the robot from its left side
  motor[armMotor] = 16;
  wait1Msec(angle * 50) // CHANGE THIS 50 LATER TO REFLECT THE ACTUAL TIME NEEDED TO ROTATE THE ARM
}

void turnClaw(int angle) { // angle is in degrees, clockwise from the robot's perspective
  motor[wristMotor] = 16;
  wait1Msec(angle * 50) // CHANGE THIS 50 LATER TO REFLECT THE ACTUAL TIME NEEDED TO ROTATE THE ARM
}

void setClawState(char state[]) { // opens/closes the claw
  int speed = 0;
  if(state[0] == 'o') {
    speed = 16;
  } else if(state[0] == 'c') {
    speed = -16;
  }
  motor[clawMotor] = speed;
  wait1Msec(1000); // probably change this time and speed
}

// this is the actual program
task main() {
	int threshold = 500; // change this later based on actual black lines

	wait1Msec(2000); // wait 2 seconds before the program starts

  for(int i = 0; i < 4; i += 1) {
    while(counter != i) { // loop until the line sensor discovers a line
      int currentLineBoi = SensorValue[lineBoi]; // just for debugging

      if(SensorValue[lineBoi] < threshold) {
        counter += 1;
      }

      backward(32);
    }

    // sonar-reliant version of above while loop
    /*
    while(SensorValue[sonarBack] > 10.375 + i * 4.75) {
      backward(32);
    }
    */
    
    turnRight(90); // if the robot gets to the line, turn right to face the pipes

    moveArm(45);
    setClawState("open"); // get ready to grab claw

    while(SensorValue[sonarFront] < 6) { // move until drive train is close enough that claw can grab pipe
      forward(32);
    }

    setClawState("closed");

    while(SensorValue[sonarBack] > 1) {
      backward(32);
    }

    turnLeft(90);

    while(SensorValue[sonarFront] < 6) {
      forward(32);
    }

    turnClaw(-90);
    setClawState("open");
    moveArm(-45); // drop pipe

    turnClaw(90);
  }
}
